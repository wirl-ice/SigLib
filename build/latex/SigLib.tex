% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}

\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{SigLib Documentation}
\date{May 24, 2018}
\release{2.7}
\author{Derek Mueller, Sougal Bouh Ali, Cindy Lopes}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}

\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro:welcome-to-siglib-s-documentation}\label{intro::doc}
SigLib stands for Signature Library and is a suite of tools to query,
manipulate and process remote sensing imagery (primarily SAR remote
sensing) and store the data in a geodatabse. It uses open source
libraries and can be run on Windows or Linux.


\section{Overview}
\label{intro:overview}
There are 4 main \emph{modes} that it can run in (or combinations of these)
\begin{enumerate}
\item {} 
A data \textbf{Discovery Mode} where remote sensing scenes are discovered
by ingesting a copy of the CIS archive (or other geodatabase
containing imagery, with tweaks), or by crawling through a hard drive
and extracting metadata from zipped SAR scenes, or by querying a
table in a local database that contains geospatial metadata. Queries
take a Region Of Interest -- \textbf{ROI shapefile} with a specific format
as input. The region of interest delineates the spatial and temporal
search boundaries and is elaborated upon in a section below.

\item {} 
An \textbf{Exploratory Mode} where remote sensing scenes are made ready
for viewing. This includes opening zip files, converting imagery
(including SLC), geographical projection, cropping, masking, image
stretching, renaming, and pyramid generation. The user must supply
the name of a single zip file that contains the SAR imagery, a
directory where a batch of zip files to be prepared resides, or a
query that selects a list of zip files to be processed (functionality
to come).

\item {} 
A \textbf{Scientific Mode} where remote sensing scenes can be converted to
either calibrated (sigma0), noise level, incidence angle images.
Image data (from each band) can be subsampled by way of an \textbf{ROI
shapefile} that references every image and specific polygon you want
to analyze. These polygons represent sampling regions that you know
about a priori or they are hand digitized from Exploratory mode
images. Data can be stored in a table in a geodatabase for further
processing. {[}Note this has not been used much either - need to shake
off the cobwebs here{]}

\item {} 
An \textbf{Analysis Mode} where data that was stored in the geodatabase is
retrieved and plotted {[}Note, this is essentially depreciated since it
hasn't been used for over 5 years{]}

\end{enumerate}

These components are brought together to work in harmony by
\textbf{SigLib.py} the recommended way to interact with the software. This
program reads in a configuration file that provides all the parameters
required to do various jobs. However, this is only one way to go...
Anyone can call the modules identified above from a custom made python
script to do what they wish.

In addition, there are different ways to process \emph{input} through
SigLib.py that can be changed for these modes. You can input based on a
recursive \textbf{scan} of a directory for files that match a pattern; you
can input one \textbf{file} at a time (useful for parallelization, when many
processes are spawned by gnu parallel) and; you can input an SQL
\textbf{query} and run the resulting matching files through SigLib (note that
query input is not yet enabled, but it wouldn't take long).


\section{Dependencies}
\label{intro:dependencies}
You will need a computer running linux or windoze (mac?... maybe, don't
know)
\begin{itemize}
\item {} 
Python 2 (not 3), along with several scientific libraries - numpy,
pandas, psycopg2, matplotlib, datetime... Recommend you install the
pythonxy or anaconda package as these contain pretty well everything
you will need (To Be Confirmed).

\item {} 
gdal/ogr libraries

\item {} 
PostrgreSQL/PostGIS could be on another computer)

\end{itemize}

Nice to haves/future...
\begin{itemize}
\item {} 
It is highly recommended that you have access to QGIS or ArcGIS to
manipulate shapefiles

\item {} 
Also, if you want to work with ASF CEOS Files, you will need ASF
MapReady (some functionality)

\item {} 
Eventually, there will be a push to integrate other remote sensing
tools - SNAP(replaces NEST,PolSARPro), CP Simulator, MADGIC, etc.

\end{itemize}


\section{Modules}
\label{intro:modules}
There are several modules that are organized according to core
functionality.
\begin{enumerate}
\item {} 
\textbf{Util.py} - a bunch of utilities for manipulating files,
shapefiles, etc

\item {} 
\textbf{Metadata.py} - used to discover and extract metadata from image
files

\item {} 
\textbf{Database.py} - used to interface between the PostGIS database for
storage and retrieval of information

\item {} 
\textbf{Image.py} - used to manipulate images, project, calibrate, crop,
etc.

\end{enumerate}

\textbf{SigLib.py} is the front-end of the software. It calls the modules
listed above and is in turn controlled by a configuration file. To run,
simply edit the *.cfg file with the paths and inputs you want and then
run siglib.py.

However, you can also code your own script to access the functionality
of the modules if you wish.


\section{Acknowledgements}
\label{intro:acknowledgements}
This software was conceived and advanced initially by Derek Mueller
(while he was a Visiting Fellow at the Canadian Ice Service). Some code
was derived from from Defence Research and Development Canada (DRDC). I
benefited from discussions with Ron Saper, Angela Cheng and My salary
was provided via a CSA GRIP project (PI Roger De Abreu).

At Carleton this code was modified further and others have worked to
improve it since the early days at CIS: Cindy Lopes (workstudy student \&
computer programmer) 2012 and Sougal Bouh-Ali (workstudy student \&
computer programmer) 2013-2016. Ron Saper, Anna Crawford and Greg
Lewis-Paley helped out as well (indirectly).


\chapter{Project Summary}
\label{project::doc}\label{project:project-summary}\begin{figure}[htbp]
\centering

\includegraphics{{UML}.png}
\end{figure}


\section{Modules}
\label{project:modules}
There are several modules that are organized according to core
functionality.
\begin{enumerate}
\item {} 
\textbf{Util.py} - a bunch of utilities for manipulating files,
shapefiles, etc

\item {} 
\textbf{Metadata.py} - used to discover and extract metadata from image
files

\item {} 
\textbf{Database.py} - used to interface between the PostGIS database for
storage and retrieval of information

\item {} 
\textbf{Image.py} - used to manipulate images, project, calibrate, crop,
etc.

\end{enumerate}

\textbf{SigLib.py} is the front-end of the software. It calls the modules
listed above and is in turn controlled by a configuration file. To run,
simply edit the *.cfg file with the paths and inputs you want and then
run siglib.py.


\section{Config File}
\label{project:config-file}
The \textbf{*.cfg} file is how you interface with siglib. It needs to be
edited properly so that the job you want done will happen! Leave entry
blank if you are not sure. There are several categories of parameters
and these are:

\textbf{Directories}
\begin{itemize}
\item {} 
scanDir = path to where you want siglib to look for files to work
with

\item {} 
tmpDir = a working directory for extracting zip files to (scratch
folder)

\item {} 
projDir = where projections are found (/tank/ice/data/proj)

\item {} 
vectDir = where vector layers are to be found (ROI shapefiles or
masking layers)

\item {} 
dataDir = /tank/path2folder

\item {} 
imgDir = a working directory for storing intermediate files and final
output (scratch folder)

\item {} 
logDir = where logs are placed

\item {} 
archDir = where CIS archive data are found
(/tank/ice/data/vector/CIS\_Archive)

\end{itemize}

\textbf{Database}
\begin{itemize}
\item {} 
db = the name of the database you want to connect to

\item {} 
create\_tblmetadata = 0 for don't create, 1 for create

\end{itemize}

\textbf{Input}

\textbf{*Note that these are mutually exclusive options - sum of `Scan'
options must = 1*}
\begin{itemize}
\item {} 
path = 1 for scan a certain path and operate on all files within, 0
otherwise

\item {} 
query = 1 for scan over the results of a query and operate on all
files returned, 0 otherwise

\item {} 
file = 1 for run process on a certain file, which is passed as a
command line argument (note this enables parallelized code), 0
otherwise

\item {} 
scanFor = a file pattern to search for (*.zip) - use when path=1

\item {} 
sql = define a custom query here for selecting data to process - use
when query=1. ex: SELECT location FROM tblmetadata WHERE granule =
`B0558007.img'

\end{itemize}

\textbf{Process}
\begin{itemize}
\item {} 
data2db = 1 when you want to upload metadata to the metadata table in
the database

\item {} 
data2img = 1 when you want to create images (as per specs below)

\end{itemize}

\textbf{Shapefile}
\begin{itemize}
\item {} 
shp = /tank/ice/data/vector/CIS\_Vectors/coast\_poly.shp

\end{itemize}

\textbf{AMPMode}
\begin{itemize}
\item {} 
proj = lcc

\item {} 
imgtypes = amp

\item {} 
crop = nothing for no cropping, or four space-delimited numbers,
upper-left and lower-right corners (in proj above) that denote a crop
area: ul\_x ul\_y lr\_x lr\_y

\item {} 
mask = a shapefile that would be used to set pixels under it to null

\item {} 
roiproj = cis\_lcc

\item {} 
imgformat = GTiff

\item {} 
roi = roi\_ntai\_flux

\item {} 
spatialrel = ST\_Contains

\end{itemize}


\section{Examples}
\label{project:examples}
You can run SigLib inside an integrated development environment (Spyder,
IDLE, etc) or at the command line. In either case you must specify the
configuration file you wish to use:

\code{python /path\_to\_script/SigLib.py /path\_to\_file/config\_file.cfg}

If you want to work on a single image then the file=1 flag must be set
in the config file and the name of the zip file needs to be specified
after the config file.

\code{python /path\_to\_script/SigLib.py /path\_to\_file/config\_file.cfg RS2\_OK2425\_PK98534\_DK23425\_20110423\_094354\_...zip}


\section{dimgname convention}
\label{project:dimgname-convention}
“The nice thing about standards is that there are so many to chose from”
(A. Tannenbaum), but this gets annoying when you pull data from MDA,
CSA, CIS, PDC, ASF and they all use different file naming conventions.
So I made this worse with my own \href{https://xkcd.com/927/}{standard image naming
convention} called \textbf{dimgname}. All files
processed by SigLib get named as follows, which is good for:
\begin{itemize}
\item {} 
sorting on date (that is the most important characteristic of an
image besides where the image is - and good luck conveying that
simply in a file name).

\item {} 
viewing in a list (because date is first, underscores keep the names
tidy in a list - you can look down to see the different beams,
satellites, etc.)

\item {} 
easy

\item {} 
extensibility - you can add on to the file name as needed - add a
subscene or whatever on the end, it will sort and view the same as
before.

\item {} 
extracting metadata from the name (in a program or spreadsheet just
parse on ``\_'')

\end{itemize}

Template: date\_time\_sat\_beam\_data\_proj.ext

Example: 20080630\_225541\_r1\_scwa\_\_hh\_s\_lcc.tif

Table: \textbf{dimgname fields}


\section{ROI.shp format}
\label{project:roi-shp-format}
The ROI.shp or Region Of Interest shapefile is what you need to extract
data. Basically it denotes \emph{where} and \emph{when} you want information. It
has to have certain fields to work properly. There are two basic
formats, based on whether you are using the \textbf{Discovery} or
\textbf{Scientific} mode. If you are interested in 1) finding out what
scenes/images might be available to cover an area or 2) generating
images over a given area then use the \emph{Discovery} format. If you have
examined the images already and have digitized polygons of areas that
you want to analyze (find statistics), then make sure those polygons are
stored in a shapefile using the \emph{Scientific} format. In either case you
must have the fields that are for \emph{Both} formats in the table below. You
can add whatever other fields you wish and some suggestions are listed
below as \emph{Optional}.

The two fields which are required for both Discovery or Scientific mode
use may be confusing, so here are some further details with examples.
\begin{itemize}
\item {} 
OBJ - this is a unique identifier for a given area or object
(polygon) that you are interested in getting data for.

\item {} 
INSTID - A way to track OBJ repeats over time (moving ice island, a
lake during fall every year for 5 years), if it doesn't repeat just
put `1'

\end{itemize}

\textbf{Example workflow:}

You could be interested in lake freeze-up in the Yukon, drifting ice
islands, or soil moisture in southern Ontario farm fields. First you
will want to find out what data are available, retrieve zip files and
generate imagery to look at. In this, case use the \emph{Discovery} format.
Each lake, region that ice islands drift through or agricultural area
that you want to study would be given a unique OBJ. If you have only one
time period in mind for each, then INSTID would be `0' in all cases. If
however, you want to look at each lake during several autumns, ice
islands as they drift or farm fields after rain events, then each OBJ
will have several rows in your shapefile with a different FROMDATE and
TODATE. Then for each new row with the same OBJ, you must modify the
INSTID such that a string that is composed of OBJ+INSTID is unique
across your shapefile. This is what is done internally by SigLib and a
new field is generated called INST (in the PostGIS database). Note that
the FROMDATE and TODATE will typically be different for each OBJ+INSTID
combination.

If you know what imagery is available already, or if you have digitized
specific areas corresponding where you want to quantify backscatter (or
image noise, incidence angle, etc), then you should use the \emph{Scientific}
format. In this case, the principles are the same as in the \emph{Discovery}
mode but your concept of what an OBJ might be different. Depending on
the study goals, you may want backscatter from the entire lake, in which
case your OBJ would be the same as in \emph{Discovery} mode, however, the
INSTID must be modified such that there is a unique OBJ+INSTID for each
image (or imagery acquisition time) you want to retrieve data for. OBJ
should change when you are hand digitizing a specific subsample from
each OBJ from the \emph{Discovery} mode. For example:
\begin{itemize}
\item {} 
within each agricultural area you may want to digitize particular
fields;

\item {} 
instead of vast areas to look for ice islands you have actually
digitized each one at a precise location and time

\end{itemize}

Build your \emph{Scientific} ROI shapefile with the field IMGREF for each
unique OBJ+INSTID instead of the FROMDATE and TODATE. By placing the
dimgname of each image you want to look at in the IMGREF field, SigLib
can pull out the date and time and populate the DATEFROM and DATETO
fields automatically. Hint: the INSTID could be IMGREF if you wished
(since there is no way an OBJ would be in the same image twice).

Once you complete your ROI.shp you can name it whatever you like (just
don't put spaces in the filename, since that causes problems).

\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\textsf{\relax 
Field
} & \textsf{\relax 
Datatype
} & \textsf{\relax 
Description
} & \textsf{\relax 
Example
} & \textsf{\relax 
ROI Format
}\\
\hline
\textbar{} OBJ
 & 
String
 & 
A unique identifier for each polygon object you are interested in
 & 
00001, 00002
 & 
Both
\\
\hline
\textbar{} INSTID
 & 
String
 & 
An iterator for each new row of the same OBJ
 & 
0,1,2,3,4
 & 
Both
\\
\hline
\textbar{} FROMDATE
 & 
String
 & 
ISO Date-time denoting the start of the time period of interest
 & 
2002-04-15 00:00:00
 & 
Discovery
\\
\hline
\textbar{} TODATE
 & 
String
 & 
ISO Date-time denoting the end of the time period of interest
 & 
2002-09-15 23:59:59
 & 
Discovery
\\
\hline
\textbar{} IMGREF
 & 
String
 & 
dimgname of a specific image known to contain the OBJ polygon (this prompts the generation of From and To Date in the program)
 & 
20020715\_135903\_r1\_scwa\_\_hh\_s\_lcc.tif
 & 
Scientific
\\
\hline
\textbar{} Name
 & 
String
 & 
A name for the OBJ is nice to have
 & 
Ward Hunt, Milne, Ayles
 & 
Optional
\\
\hline
\textbar{} Area
 & 
Float
 & 
You can calculate the Area of each polygon and put it here (choose whatever units you want)
 & 
23.42452
 & 
Optional
\\
\hline
\textbar{} Notes
 & 
String
 & 
Comment field to explain the OBJ
 & 
Georeferencing may be slightly off here?
 & 
Optional
\\
\hline\end{tabulary}


Table: \textbf{ROI.shp fields}
\begin{itemize}
\item {} 
See folder ROISamples for example ROIs - Discovery and Scientific
mode

\end{itemize}


\chapter{Using SigLib}
\label{tutorial::doc}\label{tutorial:using-siglib}\begin{figure}[htbp]
\centering

\includegraphics{{page_under_construction}.jpg}
\end{figure}


\chapter{TODO}
\label{todo:todo}\label{todo::doc}\begin{itemize}
\item {} 
Test Discover meta!

\item {} 
add proper logging to replace print statements AND standardize error
trapping and handling
\begin{enumerate}
\item {} 
capture stdout and stderr from spawned processes

\item {} 
Make sure there is process/output testing and error trapping at
every major step.

\item {} 
Need a way to isolate a reliable summary of bad images at the end.
Make sure this works in both dir scan and file input

\item {} 
Develop a test suite of imagery for the project - R2 and R1 images
that are in different beam modes, orbit directions, even bad
images to test siglib. (imagery with no EULA so it can be shared)

\end{enumerate}

\item {} 
version control (github? bitbucket?) - both software and version
identification and tracking changes for users

\item {} 
Continue documentation
\begin{enumerate}
\item {} 
every function should have complete
comments/parameters/options/return for sphinx (standard format)

\item {} 
overarching documentation important too

\item {} 
UML diagram for visual

\item {} 
example scripts/configs

\item {} 
example ROI.shp

\item {} 
run Sphinx - put all this wiki info in there...

\end{enumerate}

\item {} 
add local? {[}Not sure exactly what this is{]}

\item {} 
investigate compatibility with python 3

\end{itemize}


\section{SigLib.py}
\label{todo:siglib-py}\begin{itemize}
\item {} 
add `modes' to this - so that siglib can do what is described above.

\item {} 
add qryDatabase stuff or at least some of it (part of discovery mode)

\item {} 
update config.cfg accordingly

\end{itemize}


\section{Metadata.py}
\label{todo:metadata-py}\begin{itemize}
\item {} 
get look direction for RSAT2, test against RSAT1

\end{itemize}


\section{Database.py}
\label{todo:database-py}\begin{itemize}
\item {} 
test now that I replaced srid 914 with 4326

\item {} 
qryfromlocal... {[}not too sure what this is?{]}

\end{itemize}


\section{Image.py}
\label{todo:image-py}\begin{itemize}
\item {} 
test Pauli decomp and write in a switch for this - so users can
choose?

\item {} 
test image crop and mask - in both modes

\end{itemize}


\section{Util.py}
\label{todo:util-py}\begin{itemize}
\item {} 
deltree needs work (or can it be removed?)

\end{itemize}


\section{Sphinx}
\label{todo:sphinx}\begin{itemize}
\item {} 
pandoc -s -S -f mediawiki intro.wik -t rst -o intro.rst

\end{itemize}


\chapter{SigLib API}
\label{code:siglib-api}\label{code::doc}

\section{SigLib}
\label{code:module-SigLib}\label{code:siglib}\index{SigLib (module)}
\textbf{SigLib.py}

This script will bring together all the SigLib modules with a config script to

\textbf{Created on} Mon Oct  7 20:27:19 2013 \textbf{@author:} Sougal Bouh Ali
\textbf{Modified on} Wed May  23 11:37:40 2018 \textbf{@reason:} Sent instance of Metadata to data2img instead of calling Metadata again \textbf{@author:} Cameron Fitzpatrick
\index{SigLib (class in SigLib)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib}\pysigline{\strong{class }\code{SigLib.}\bfcode{SigLib}}~\index{createLog() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.createLog}\pysiglinewithargsret{\bfcode{createLog}}{\emph{zipfile=None}}{}
Creates log file that will be used to report progress and errors
\textbf{Parameters}
\begin{quote}

\emph{zipfile} : a valid zipfile name with full path (optional) for file input
\end{quote}

\end{fulllineitems}

\index{data2db() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.data2db}\pysiglinewithargsret{\bfcode{data2db}}{\emph{meta}, \emph{db}, \emph{zipfile}}{}
Adds the image file metadata to tblmetadata table in the specified database.
Will create/overwrite the table tblmetadata if prompted (be carefull)

\textbf{Parameters}
\begin{quote}

\emph{meta} :   A metadata instance from Metadata.py

\emph{db}   :   database connection
\end{quote}

\end{fulllineitems}

\index{data2img() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.data2img}\pysiglinewithargsret{\bfcode{data2img}}{\emph{fname}, \emph{imgname}, \emph{zipname}, \emph{sattype}, \emph{granule}, \emph{zipfile}, \emph{sar\_meta}, \emph{unzipdir}}{}
Opens an image file and converts it to the format given in the config file

\textbf{Parameters}
\begin{quote}

\emph{fname}    : image filename (i.e. R1\_980705\_114117.img OR product.xml)

\emph{imgname}  : image name (i.e. R1\_980705\_114117)

\emph{zipname}  : zipname

\emph{sattype}  : satelite platform

\emph{granule}  : granule name

\emph{zipfile}  : zipfile

\emph{unzipdir} : unzip directory
\end{quote}

\end{fulllineitems}

\index{handler() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.handler}\pysiglinewithargsret{\bfcode{handler}}{\emph{signum}, \emph{frame}}{}
Handles exceptions - most notably time out errors

\end{fulllineitems}

\index{proc\_Dir() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.proc_Dir}\pysiglinewithargsret{\bfcode{proc\_Dir}}{\emph{path}, \emph{pattern}}{}
Locates satelite image raw data files (zipfiles) using a
\emph{pattern} in \emph{path} search method, and then calls createImg()
to process the data into image.

\textbf{Parameters}
\begin{quote}

\emph{path}    : directory tree to scan

\emph{pattern} : file pattern to discover
\end{quote}

\end{fulllineitems}

\index{proc\_File() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.proc_File}\pysiglinewithargsret{\bfcode{proc\_File}}{\emph{zipfile}}{}
Locates a single satellite image zip file and processes it according 
to the config file.  Note this cannot be nested in proc\_dir since the 
logging structure and other elements must parallelizable

\textbf{Parameters}
\begin{quote}

\emph{zipfile} : a valid zipfile name with full path
\end{quote}

\end{fulllineitems}

\index{retrieve() (SigLib.SigLib method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.SigLib.retrieve}\pysiglinewithargsret{\bfcode{retrieve}}{\emph{zipfile}}{}
Given a zip file name this function will: find out what satellite it is, unzip it, get instance of metadata, then 
dependant on the config, save metadata in a file and/or one of the following: Process to image or process to database.

\textbf{Parameters}
\begin{quote}

\emph{zipfile} : A valid zipfile name with full extention
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Metadata}
\label{code:metadata}\index{Metadata (class in SigLib)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.Metadata}\pysiglinewithargsret{\strong{class }\code{SigLib.}\bfcode{Metadata}}{\emph{granule}, \emph{imgname}, \emph{path}, \emph{zipfile}, \emph{sattype}, \emph{loghandler=None}}{}
This is the metadata class for each image RSAT2, RSAT1 (ASF and CDPF)
\index{\_\_init\_\_() (SigLib.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:SigLib.Metadata.__init__}\pysiglinewithargsret{\bfcode{\_\_init\_\_}}{\emph{granule}, \emph{imgname}, \emph{path}, \emph{zipfile}, \emph{sattype}, \emph{loghandler=None}}{}
This initializes the class based on input

\textbf{Parameters}
\begin{quote}

\emph{granule}    : unique name of the image (String)

\emph{imgname}    : name of the file to open, representing the image (String)

\emph{path}       : path to the image (String)

\emph{Zipfile}    : A valid zipfile name with full path (String)

\emph{sattype}    : type of data (String)

\emph{loghandler} : A valid pre-set loghandler (Optional)
\end{quote}

\textbf{Returns}
\begin{quote}

An instance of Meta
\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{code:module-Metadata}\index{Metadata (module)}
\textbf{Metadata.py}

\textbf{Created on} Jan 1, 2009 \textbf{@author:} Derek Mueller

This module creates an instance of class Meta and contains functions to
query raw data files for metadata which is standardized and packaged for
later use, output to file, upload to database, etc.
\begin{quote}

\emph{This source code to extract metadata from CEOS-format RADARSAT-1 
data was developed by Defence Research and Development Canada
{[}Used with permission{]}}
\end{quote}
\index{Metadata (class in Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata}\pysiglinewithargsret{\strong{class }\code{Metadata.}\bfcode{Metadata}}{\emph{granule}, \emph{imgname}, \emph{path}, \emph{zipfile}, \emph{sattype}, \emph{loghandler=None}}{}
This is the metadata class for each image RSAT2, RSAT1 (ASF and CDPF)
\index{clean\_metaASF() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.clean_metaASF}\pysiglinewithargsret{\bfcode{clean\_metaASF}}{\emph{result}}{}
Takes meta data from origmeta and checks it for completeness, coerces data types
splits values, if required and puts it all into a standard format

NOT TESTED!!

\textbf{Parameters}
\begin{quote}

\emph{result} : Dictionary of metadata
\end{quote}

\end{fulllineitems}

\index{clean\_metaCDPF() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.clean_metaCDPF}\pysiglinewithargsret{\bfcode{clean\_metaCDPF}}{\emph{result}}{}
Takes meta data from origmeta and checks it for completeness, coerces data types
splits values, if required and puts it all into a standard format

\textbf{Parameters}
\begin{quote}

\emph{result} : A dictonary of metadata
\end{quote}

\end{fulllineitems}

\index{createMetaDict() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.createMetaDict}\pysiglinewithargsret{\bfcode{createMetaDict}}{}{}
Creates a dictionary of all the metadata fields for an image
this can be written to file or sent to database

Note that the long boring metadata fields are not included

\textbf{Returns}
\begin{quote}

\emph{metadict} : Dictionary containing all the metadata fields
\end{quote}

\end{fulllineitems}

\index{extractGCPs() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.extractGCPs}\pysiglinewithargsret{\bfcode{extractGCPs}}{\emph{interval}}{}
Description needed!

\textbf{Parameters}
\begin{quote}

\emph{interval}    :
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{tuple(gcps)} : GCP's returned in tuple format
\end{quote}

\end{fulllineitems}

\index{getASFMetaCorners() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getASFMetaCorners}\pysiglinewithargsret{\bfcode{getASFMetaCorners}}{\emph{ASFName}}{}
Use ASF Mapready to generate the metadata

\textbf{Parameters}
\begin{quote}

\emph{ASFName} : ?
\end{quote}

\end{fulllineitems}

\index{getASFProductType() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getASFProductType}\pysiglinewithargsret{\bfcode{getASFProductType}}{\emph{ASFName}}{}
Description needed!

\textbf{Parameters}
\begin{quote}

\emph{ASFName} : ?
\end{quote}

\end{fulllineitems}

\index{getCEOSmetafile() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getCEOSmetafile}\pysiglinewithargsret{\bfcode{getCEOSmetafile}}{}{}
Get the filenames for metadata

\end{fulllineitems}

\index{getCornerPoints() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getCornerPoints}\pysiglinewithargsret{\bfcode{getCornerPoints}}{}{}
Given a set of geopts, calculate the corner coords to the nearest 1/2
pixel. Assumes that the corners are among the GCPs (not randomly placed)

\end{fulllineitems}

\index{getDimgname() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getDimgname}\pysiglinewithargsret{\bfcode{getDimgname}}{}{}~\begin{description}
\item[{Create a filename that conforms to my own standard naming convention:}] \leavevmode
yyyymmdd\_HHmmss\_sat\_beam\_pol...

\end{description}

\textbf{Returns}
\begin{quote}

\emph{dimgname} : Name for image file conforming to standards above
\end{quote}

\end{fulllineitems}

\index{getMoreGCPs() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getMoreGCPs}\pysiglinewithargsret{\bfcode{getMoreGCPs}}{\emph{n\_gcps}}{}
If you have a CDPF RSat1 image, gdal only has 15 GCPs
Perhaps you want more?  If so, use this function.
It will grab all the GCPs available (3 on each line) and
subselect n\_gcps of these to return.

The GCPs will not necessarily be on the `bottom corners' since the gcps
will be spaced evenly to get n\_gcps (or more if not divisible by 3)
If you want corners the only way to guarentee this is to set n\_gcps = 6

\textbf{Parameters}
\begin{quote}

\emph{n\_gcps}      : \# of GCP's to return
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{tuple(gcps)} : \# of GCP's specified returned in tuple format
\end{quote}

\end{fulllineitems}

\index{getRS2metadata() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getRS2metadata}\pysiglinewithargsret{\bfcode{getRS2metadata}}{}{}
Open a Radarsat2 file and get all the required metadata

\end{fulllineitems}

\index{get\_ceos\_metadata() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.get_ceos_metadata}\pysiglinewithargsret{\bfcode{get\_ceos\_metadata}}{\emph{*file\_names}}{}
Take file names as input and return a dictionary of metadata
file\_names is a list of strings or a string (with one filename)

This source code to extract metadata from CEOS-format RADARSAT-1 
data was developed by Defence Research and Development Canada
{[}Used with Permission{]}

\textbf{Parameters}
\begin{quote}

{\color{red}\bfseries{}**}file\_names* : List of strings
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{result}     : Dictionary of Metadata
\end{quote}

\end{fulllineitems}

\index{getgdalmeta() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.getgdalmeta}\pysiglinewithargsret{\bfcode{getgdalmeta}}{}{}
Open file with gdal and get metadata

\textbf{Returns}
\begin{quote}

\emph{gdal\_meta} : Metadata found by gdal
\end{quote}

\end{fulllineitems}

\index{saveMetaFile() (Metadata.Metadata method)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.Metadata.saveMetaFile}\pysiglinewithargsret{\bfcode{saveMetaFile}}{\emph{dir='`}}{}
Makes a text file with the metadata

\end{fulllineitems}


\end{fulllineitems}

\index{byte2int() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.byte2int}\pysiglinewithargsret{\code{Metadata.}\bfcode{byte2int}}{\emph{byte}}{}
Reads a byte and converts to integer

\end{fulllineitems}

\index{date2doy() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.date2doy}\pysiglinewithargsret{\code{Metadata.}\bfcode{date2doy}}{\emph{date}, \emph{string=False}, \emph{float=False}}{}
Give a python datetime and get an integer or string doy fractional doy returned if float=True

\end{fulllineitems}

\index{datetime2iso() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.datetime2iso}\pysiglinewithargsret{\code{Metadata.}\bfcode{datetime2iso}}{\emph{datetimeobj}}{}
Return iso string from a python datetime

\end{fulllineitems}

\index{getEarthRadius() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.getEarthRadius}\pysiglinewithargsret{\code{Metadata.}\bfcode{getEarthRadius}}{\emph{ellip\_maj}, \emph{ellip\_min}, \emph{plat\_lat}}{}
Calculates the earth radius at the latitude of the satellite from the ellipsoid params

\end{fulllineitems}

\index{getGroundRange() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.getGroundRange}\pysiglinewithargsret{\code{Metadata.}\bfcode{getGroundRange}}{\emph{slantRange}, \emph{radius}, \emph{sat\_alt}}{}
Finds the ground range from nadir which corresponds to a given slant range
must be an slc image, must have calculated the slantRange first

\end{fulllineitems}

\index{getSlantRange() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.getSlantRange}\pysiglinewithargsret{\code{Metadata.}\bfcode{getSlantRange}}{\emph{gsr}, \emph{pixelSpacing}, \emph{n\_cols}, \emph{order\_Rg}, \emph{groundRangeOrigin=0.0}}{}~\begin{description}
\item[{gsr = ground to slant range coefficients -a list of 6 floats}] \leavevmode
pixelSpacing - the img. res., n\_cols - how many pixels in range
ground range orig - for RSat2 (seems to be zero always)

Valid for SLC as well as SGF

\end{description}

\end{fulllineitems}

\index{getThetaPixel() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.getThetaPixel}\pysiglinewithargsret{\code{Metadata.}\bfcode{getThetaPixel}}{\emph{RS}, \emph{r}, \emph{h}}{}
Calc the incidence angle at a given pixel

\end{fulllineitems}

\index{getThetaVector() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.getThetaVector}\pysiglinewithargsret{\code{Metadata.}\bfcode{getThetaVector}}{\emph{n\_cols}, \emph{slantRange}, \emph{radius}, \emph{sat\_alt}}{}
Make a vector of incidence angles in range direction

\end{fulllineitems}

\index{get\_data\_block() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.get_data_block}\pysiglinewithargsret{\code{Metadata.}\bfcode{get\_data\_block}}{\emph{fp}, \emph{offset}, \emph{length}}{}
gets a block of data from file

\end{fulllineitems}

\index{get\_field\_value() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.get_field_value}\pysiglinewithargsret{\code{Metadata.}\bfcode{get\_field\_value}}{\emph{data}, \emph{field\_type}, \emph{length}, \emph{offset}}{}
Description needed!

\textbf{Parameters}
\begin{quote}

\emph{data}       :

\emph{field\_type} :

\emph{length}     :

\emph{offset}     :
\end{quote}

\textbf{Returns}
\begin{quote}

converted data\_str
\end{quote}

\end{fulllineitems}

\index{readdate() (in module Metadata)}

\begin{fulllineitems}
\phantomsection\label{code:Metadata.readdate}\pysiglinewithargsret{\code{Metadata.}\bfcode{readdate}}{\emph{date}, \emph{sattype}}{}
Takes a rsat2 formated date 2009-05-31T14:43:17.184550Z
and converts it to python datetime

\end{fulllineitems}



\section{Image Processing}
\label{code:image-processing}\phantomsection\label{code:module-Image}\index{Image (module)}
\textbf{imgProcess.py}

\textbf{Created on} ??? Jul  ? ??:??:?? 2009 \textbf{@author:} Derek Mueller

This module creates an instance of class Img and opens a file to return a
gdal dataset to be processed into an amplitude, calibrated, noise or theta
(incidence angle) image, etc. This image can be subsequently projected,
cropped, masked, stretched, etc.

\textbf{Modified on} ??? Feb  ? ??:??:?? 2012 \textbf{@reason:} Repackaged for r2convert \textbf{@author:} Derek Mueller
\textbf{Modified on} 23 May 14:43:40 2018 \textbf{@reason:} Added logging functionality \textbf{@author:} Cameron Fitzpatrick
\index{Image (class in Image)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image}\pysiglinewithargsret{\strong{class }\code{Image.}\bfcode{Image}}{\emph{fname}, \emph{path}, \emph{meta}, \emph{imgType}, \emph{imgFormat}, \emph{zipname}, \emph{loghandler=None}}{}
This is the Img class for each image.  RSAT2, RSAT1 (ASF and CDPF)

Opens the file specified by fname, passes reference to the meta class and declares the imgType of interest.
\begin{quote}

\textbf{Parameters}
\begin{quote}

\emph{fname}     : filename

\emph{path}      : full directory path of the filename

\emph{meta}      : reference to the meta class

\emph{imgType}   : amp, sigma, noise, theta...

\emph{imgFormat} : gdal format code gtiff, vrt

\emph{zipname}   : name of the image's zipfile
\end{quote}
\end{quote}
\index{applyStretch() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.applyStretch}\pysiglinewithargsret{\bfcode{applyStretch}}{\emph{stats}, \emph{procedure='std'}, \emph{sd=3}, \emph{bitDepth=8}, \emph{sep='tog'}}{}
Given stats... will stretch a multiband image to the dataType based on
procedure (either sd for standard deviation, with +ve int in keyword sd,
or min-max, also a linear stretch).

!!A nodata value of 0 is used in all cases!!

!!For now, dataType is byte and that's it!!

\textbf{Note:} gdal\_translate -scale does not honour nodata values
See: \href{http://trac.osgeo.org/gdal/ticket/3085}{http://trac.osgeo.org/gdal/ticket/3085}

Have to run this one under the imgWrite code. The raster bands must be integer, float? or byte
and int data assumed to be only positive. Won't work very well for dB scaled data (obviously)
it is important that noData is set to 0 and is meaningful.

sep = separate: applies individual stretches to each band (=better visualization/contrast)

tog = together: applies the same stretch to all bands (looks for the band with the greatest dynamic range) (=more `correct')

For further ideas see: \href{http://en.wikipedia.org/wiki/Histogram\_equalization}{http://en.wikipedia.org/wiki/Histogram\_equalization}

\end{fulllineitems}

\index{cleanFiles() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.cleanFiles}\pysiglinewithargsret{\bfcode{cleanFiles}}{\emph{levels={[}'crop'{]}}}{}
Removes files that have been written.

Input a list of items to delete: raw, nil, proj,crop

\textbf{Parameters}
\begin{quote}

\emph{levels} : a list of different types of files to delete
\end{quote}

\end{fulllineitems}

\index{cropBig() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.cropBig}\pysiglinewithargsret{\bfcode{cropBig}}{\emph{llur}, \emph{subscene}}{}
Here we have a way to crop that will expand the area of an image.
However, this uses gdalwarp - and resampling/offsetting could skew result - by a fraction of a pixel obviously, but still..

\textbf{Parameters}
\begin{quote}

\emph{llur}     : list/tuple of tuples in projected units

\emph{subscene} : the name of a subscene
\end{quote}

\end{fulllineitems}

\index{cropImg() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.cropImg}\pysiglinewithargsret{\bfcode{cropImg}}{\emph{ullr}, \emph{subscene}}{}
Given the cropping coordinates, this function tries to crop in a straight-forward way.
If this cannot be accomplished (likely because the corner coordinates of an image are not known to a sufficient precision)
then gdalwarp (cropBig) will do the job.

\textbf{Parameters}
\begin{quote}

\emph{ullr}     : upper left and lower right coordinates

\emph{subscene} : the name of a subscene
\end{quote}

\end{fulllineitems}

\index{cropSmall() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.cropSmall}\pysiglinewithargsret{\bfcode{cropSmall}}{\emph{urll}, \emph{subscene}}{}
This is a better way to crop b/c no potential for warping...
However, this will only work if the region falls completely within the image.

\textbf{Parameters}
\begin{quote}

\emph{urll}     : list/tuple of tuples in projected units

\emph{subscene} : the name of a subscene
\end{quote}

\end{fulllineitems}

\index{decomp() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.decomp}\pysiglinewithargsret{\bfcode{decomp}}{\emph{format='imgFormat'}}{}
Takes an input ds of a fully polarimetric image and writes an image of
the data using a decomposition - could be 1) pauli

TODO: 2) freeman 3) cloude

Differs from imgWrite b/c it ingests all bands at once...

\end{fulllineitems}

\index{fnameGenerate() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.fnameGenerate}\pysiglinewithargsret{\bfcode{fnameGenerate}}{\emph{projout=None}, \emph{subset=None}, \emph{band=None}}{}
Decide on some parameters based on self.imgType we want...

\textbf{Returns}
\begin{quote}

\emph{bands}    : Integer

\emph{dataType} : GDal data type

\emph{outname}  : String
\end{quote}

\end{fulllineitems}

\index{getAmp() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getAmp}\pysiglinewithargsret{\bfcode{getAmp}}{\emph{datachunk}}{}
return the amplitude, given the amplitude... but make room for
the nodata value by clipping the highest value...

\end{fulllineitems}

\index{getBandData() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getBandData}\pysiglinewithargsret{\bfcode{getBandData}}{\emph{band}}{}
opens an img file and reads in data from a given band
assume that the dataset is small enough to fit into memory all at once

\textbf{Returns}
\begin{quote}

\emph{imgData}  : data from the given band

\emph{xSpacing} :

\emph{ySpacing} :
\end{quote}

\end{fulllineitems}

\index{getImgStats() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getImgStats}\pysiglinewithargsret{\bfcode{getImgStats}}{}{}
Opens a raster and calculates (approx) the stats
returns an array - 1 row per band
cols: band, dynamicRange, dataType, nodata value, min, max, mean, std

\textbf{Returns}
\begin{quote}

\emph{stats} : stats from raster returned in an array of 1 row per band
\end{quote}

\end{fulllineitems}

\index{getMag() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getMag}\pysiglinewithargsret{\bfcode{getMag}}{\emph{datachunk}}{}
return the magnitude of the complex number

\end{fulllineitems}

\index{getNoise() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getNoise}\pysiglinewithargsret{\bfcode{getNoise}}{\emph{n\_lines}}{}
For making an image with the noise floor as data

\end{fulllineitems}

\index{getPhase() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getPhase}\pysiglinewithargsret{\bfcode{getPhase}}{\emph{datachunk}}{}
Return the phase (in radians) of the data (must be complex/SLC)

\end{fulllineitems}

\index{getSigma() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getSigma}\pysiglinewithargsret{\bfcode{getSigma}}{\emph{datachunk}, \emph{n\_lines}}{}
Calibrate data to Sigma Nought values (linear scale)

\end{fulllineitems}

\index{getTheta() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.getTheta}\pysiglinewithargsret{\bfcode{getTheta}}{\emph{n\_lines}}{}
For making an image with the incidence angle as data

\end{fulllineitems}

\index{imgWrite() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.imgWrite}\pysiglinewithargsret{\bfcode{imgWrite}}{\emph{format='imgFormat'}, \emph{stretchVals=None}}{}
Takes an input ds and writes an image.

self.imgType could be 1) amp, 2) sigma, 3) noise, 4) theta

all bands are output (amp, sigma)

Also used to scale an integer img to byte with stretch, if stretchVals are included
\begin{description}
\item[{Note there is a parameter called chunk\_size hard coded here that could be changed }] \leavevmode
If you are running with lots of RAM

\end{description}

\end{fulllineitems}

\index{makePyramids() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.makePyramids}\pysiglinewithargsret{\bfcode{makePyramids}}{}{}
Uses gdaladdo to make pyramids aux style

\end{fulllineitems}

\index{maskImg() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.maskImg}\pysiglinewithargsret{\bfcode{maskImg}}{\emph{mask}, \emph{vectdir}, \emph{side}, \emph{imgType}}{}
Masks all bands with gdal\_rasterize using the `layer'

side = `inside' burns 0 inside the vector, `outside' burns outside the vector

Note: make sure that the vector shapefile is in the same proj as img (Use reprojSHP from ingestutil)

\textbf{Parameters}
\begin{quote}

\emph{mask}    :

\emph{vectdir} :

\emph{side}    :

\emph{imgType} :
\end{quote}

\end{fulllineitems}

\index{openDataset() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.openDataset}\pysiglinewithargsret{\bfcode{openDataset}}{\emph{fname}, \emph{path='`}}{}
Opens a dataset with gdal

\textbf{Parameters}
\begin{quote}

\emph{fname} : filename
\end{quote}

\end{fulllineitems}

\index{projectImg() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.projectImg}\pysiglinewithargsret{\bfcode{projectImg}}{\emph{projout}, \emph{projdir}, \emph{format=None}, \emph{resample='bilinear'}, \emph{clobber=True}}{}
Looks for a file, already created and projects it to a vrt file.

\textbf{Parameters}
\begin{quote}

\emph{projout}  : projection base name

\emph{projdir}  : path to the projection

\emph{format}   : the image format, defaults to VRT

\emph{resample} : resample method (as per gdalwarp)

\emph{clobber}  : True/False should old output be overwritten?
\end{quote}

NOTE THE PIXEL SIZE IS NOT PROSCRIBED! (it will be the smallest possible)

\end{fulllineitems}

\index{reduceImg() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.reduceImg}\pysiglinewithargsret{\bfcode{reduceImg}}{\emph{xfactor}, \emph{yfactor}}{}
Uses gdal to reduce the image by a given factor (i.e, factor 2 is 50\%
smaller or half the \# of pixels) and saves as a temporary file and then overwrites.

\textbf{Parameters}
\begin{quote}

\emph{xfactor} : float

\emph{yfactor} : float
\end{quote}

\end{fulllineitems}

\index{stretchLinear() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.stretchLinear}\pysiglinewithargsret{\bfcode{stretchLinear}}{\emph{datachunk}, \emph{scaleRange}, \emph{dynRange}, \emph{minVal}, \emph{offset=0}}{}
Simple linear rescale: where min (max) can be the actual min/max or mean+/- n*std or any other cutoff

Note: make sure min/max don't exceed the natural limits of dataType
takes a numpy array datachunk the range to scale to, the range to scale
from, the minVal to start from and an offset required for some stretches
(see applyStretch keyword sep/tog)

\textbf{Parameters}
\begin{quote}

\emph{datachunk}   : array

\emph{scaleRange}  : Range to scale to

\emph{dynRange}    : Range to scale from

\emph{minVal}      : strating min value
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{stretchData} : datachunk, now linearly rescaled
\end{quote}

\end{fulllineitems}

\index{vrt2RealImg() (Image.Image method)}

\begin{fulllineitems}
\phantomsection\label{code:Image.Image.vrt2RealImg}\pysiglinewithargsret{\bfcode{vrt2RealImg}}{\emph{subset=None}}{}
When it is time to convert a vrt to a tiff (or even img, etc) use this

\end{fulllineitems}


\end{fulllineitems}



\section{Database}
\label{code:database}\phantomsection\label{code:module-Database}\index{Database (module)}
\textbf{Database.py}

\textbf{Created on} Tue Feb 12 23:12:13 2013 \textbf{@author:} Cindy Lopes

This module creates an instance of class Database and connects to a database to
create, update and query tables.

Tables of note include:

\textbf{tblmetadata} - a table that contains metadata that is gleaned by a directory scan
\textbf{roi\_tbl} - a table with a region of interest (could be named something else)
\textbf{trel\_roiinst\_con} or \_int - a relational table that results from a spatial query
\textbf{tblArchive} - a copy of the metadata from the CIS image archive

Other tables could contain data from drifting beacons or other data

\textbf{Modified on} 23 May 14:43:40 2018 \textbf{@reason:} Added logging functionality \textbf{@author:} Cameron Fitzpatrick
\index{Database (class in Database)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database}\pysiglinewithargsret{\strong{class }\code{Database.}\bfcode{Database}}{\emph{dbname}, \emph{user=None}, \emph{password=None}, \emph{port=`5432'}, \emph{host='localhost'}, \emph{loghandler=None}}{}
This is the Database class for each database connection.
\begin{description}
\item[{Creates a connection to the specified database.  You can connect as a specific user or }] \leavevmode
default to your own username, which assumes you have privileges and a password stored in your  \textasciitilde{}/.pgpass file

Note: if you have any issues with a bad query, send a rollback to the database to reset the connection.
\textgreater{}\textgreater{}\textgreater{}\textgreater{}db.connection.rollback()

\textbf{Parameters}
\begin{quote}

\emph{dbname}   : database name

\emph{user}     : user with sudo access on the specified databse (i.e. postgres user has sudo access to all databses)

\emph{password} : password to go with user

\emph{port}     : server port (i.e. 5432)

\emph{host}     : hostname (i.e. localhost)
\end{quote}

\end{description}
\index{alterTimestamp() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.alterTimestamp}\pysiglinewithargsret{\bfcode{alterTimestamp}}{\emph{shpTable}}{}
Takes a shape file and converts the gps\_time from character type to timestamp time.

\textbf{Parameters}
\begin{quote}

\emph{shpTable} :
\end{quote}

\end{fulllineitems}

\index{beaconShapefilesToTables() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.beaconShapefilesToTables}\pysiglinewithargsret{\bfcode{beaconShapefilesToTables}}{\emph{dirName}}{}
Takes a directory containing beacon shape files and converts them to tables and 
inserts them into the database appending \emph{beacon\_} before the name

\textbf{Parameters}
\begin{quote}

\emph{dirName} :
\end{quote}

\end{fulllineitems}

\index{bothArchiveandMetadata() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.bothArchiveandMetadata}\pysiglinewithargsret{\bfcode{bothArchiveandMetadata}}{}{}
Finds all the results in both the archive and tblmetadata.

\end{fulllineitems}

\index{checkTblArchiveOverLapsTblMetadata() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.checkTblArchiveOverLapsTblMetadata}\pysiglinewithargsret{\bfcode{checkTblArchiveOverLapsTblMetadata}}{\emph{filename}}{}
Check if a file name from tblArchive is in the overlap table.

\textbf{Parameters}
\begin{quote}

\emph{filename}   :
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{dictionary} :
\end{quote}

\end{fulllineitems}

\index{copyfiles() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.copyfiles}\pysiglinewithargsret{\bfcode{copyfiles}}{\emph{copylist}, \emph{wrkdir}}{}
Copies files from cisarchive.  If file could not be found, check that the 
drive mapping is correct (above).

\textbf{Parameters}
\begin{quote}

\emph{copylist} : a list of images + inst

\emph{wrkdir}   : working directory
\end{quote}

\end{fulllineitems}

\index{copylistExport() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.copylistExport}\pysiglinewithargsret{\bfcode{copylistExport}}{\emph{copylist}, \emph{fname}}{}
Saves the copylist as a text file named fname.txt in the current dir.

\textbf{Parameters}
\begin{quote}

\emph{copylist} : a list of images - catalog ids or files
\begin{quote}

\emph{fname}    : filename to write copylist to
\end{quote}
\end{quote}

\end{fulllineitems}

\index{copylistImport() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.copylistImport}\pysiglinewithargsret{\bfcode{copylistImport}}{\emph{fname}}{}
Reads the copylist text file named fname.txt in the current dir.

\textbf{Parameters}
\begin{quote}

\emph{fname}        : filename to read copylist from
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{new\_copylist} : a list of images + inst
\end{quote}

\end{fulllineitems}

\index{createTblMetadata() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.createTblMetadata}\pysiglinewithargsret{\bfcode{createTblMetadata}}{}{}
Creates a metadata table called \emph{tblmetadata}. It overwrites if \emph{tblmetadata} already exist.

\end{fulllineitems}

\index{customizedQuery() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.customizedQuery}\pysiglinewithargsret{\bfcode{customizedQuery}}{\emph{attributeList}, \emph{roi}, \emph{spatialrel}, \emph{proj}}{}
Customizable query that takes an list of attributes to search for, a roi, a spatialrel, and a proj
and returns a dictionary with all the requested attributes for the results that matched the query

\textbf{Parameters}
\begin{quote}

\emph{attributeList} :

\emph{roi}           :

\emph{spatialrel}    :

\emph{proj}          :
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{copylist}      :

\emph{instimg}       :
\end{quote}

\end{fulllineitems}

\index{dbProj() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.dbProj}\pysiglinewithargsret{\bfcode{dbProj}}{\emph{proj}}{}
Relates \emph{proj} the name (ie. proj.wkt) to \emph{proj} the number (i.e. srid \#).
from Metadata import Metadata
\textbf{Parameters}
\begin{quote}

\emph{proj} : projection name
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{srid} : spatial reference id number of that projection
\end{quote}

\end{fulllineitems}

\index{exportToCSV() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.exportToCSV}\pysiglinewithargsret{\bfcode{exportToCSV}}{\emph{qryOutput}, \emph{outputName}}{}
Given a dictionary of results from the database and a filename puts all the results
into a csv with the filename outputName

\textbf{Parameters}
\begin{quote}

\emph{qryOutput}  : output from a query - needs to be a tupple - numpy data and list of column names

\emph{outputName} : the file name
\end{quote}

\end{fulllineitems}

\index{imgData2db() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.imgData2db}\pysiglinewithargsret{\bfcode{imgData2db}}{\emph{imgData}, \emph{xSpacing}, \emph{ySpacing}, \emph{bandName}, \emph{inst}, \emph{dimgname}, \emph{granule}}{}
Here are the data in an array... upload to database
need the imgData, the imgType, the bandName, the inst, dimgname and granule

will compute the count, mean, std, min, max for non-zero elements
and send them to db as well

\textbf{Parameters}
\begin{quote}

\emph{imgData}   :

\emph{xSpacing}  :

\emph{ySpacing}  :

\emph{bandName}  :

\emph{inst}      : instance id (i.e. a 5-digit string)

\emph{dimgname}  : Derek's image name

\emph{granule}   : granule name
\end{quote}

\end{fulllineitems}

\index{instimg2db() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.instimg2db}\pysiglinewithargsret{\bfcode{instimg2db}}{\emph{roi}, \emph{spatialrel}, \emph{instimg}, \emph{mode='refresh'}}{}
There can be several relational tables that contain the name of an image
and the feature that it relates to:
For example:  a table that shows what images intersect with general areas or
a table that lists images that contain ROI polygons...

This function runs in create mode or refresh mode
Create - Drops and re-creates the table

Refresh - Adds new data (leaves the old stuff intact)

\textbf{Parameters}
\begin{quote}

\emph{roi}        : region of interest table

\emph{spatialrel} : spatial relationship (i.e. ST\_Contains or ST\_Intersect)

\emph{instimg}    : a list of only images of that instance id

\emph{copylist}   : a list of images + inst

\emph{mode}       : create or refresh mode
\end{quote}

\end{fulllineitems}

\index{instimgExport() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.instimgExport}\pysiglinewithargsret{\bfcode{instimgExport}}{\emph{instimg}, \emph{fname}}{}
Saves the instimg listing as a csv file named fname.csv in the current dir.

\textbf{Parameters}
\begin{quote}

\emph{instimg} : a list of images and where they cover
\begin{quote}

\emph{fname}   : filename to write to
\end{quote}
\end{quote}

\end{fulllineitems}

\index{meta2db() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.meta2db}\pysiglinewithargsret{\bfcode{meta2db}}{\emph{metaDict}, \emph{overwrite=True}}{}
Uploads image metadata to the database as discovered by the meta module.
\emph{meta} is a dictionary - no need to upload all the fields (some are not
included in the table structure)

Note that granule and dimgname are unique - as a precaution - a first query
deletes records that would otherwise be duplicated 
This assumes that they should be overwritten!

\textbf{Parameters}
\begin{quote}

\emph{metaDict} : dictionnary containing the metadata
\end{quote}

\end{fulllineitems}

\index{nameTable() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.nameTable}\pysiglinewithargsret{\bfcode{nameTable}}{\emph{roi}, \emph{spatialrel}}{}
Automatically gives a name to a relational table

\textbf{Parameters}
\begin{quote}

\emph{roi}        : region of interest

\emph{spatialrel} : spatial relationship (i.e. ST\_Contains or ST\_Intersect)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{name}       : name of the table
\end{quote}

\end{fulllineitems}

\index{numpy2sql() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.numpy2sql}\pysiglinewithargsret{\bfcode{numpy2sql}}{\emph{numpyArray}, \emph{dims}}{}
Converts a 1- or 2-D numpy array to an sql friendly array
Do not use with a string array!

\textbf{Parameters}
\begin{quote}

\emph{numpyArray} : numpy array to convert

\emph{dims}       : dimension (1 or 2)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{array\_sql}  : an sql friendly array
\end{quote}

\end{fulllineitems}

\index{qryCropZone() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qryCropZone}\pysiglinewithargsret{\bfcode{qryCropZone}}{\emph{granule}, \emph{roi}, \emph{spatialrel}, \emph{proj}, \emph{inst}}{}
Writes a query to fetch the bounding box of the area that the inst polygon and
image in question intersect.
returns a crop ullr tupple pair in the projection given

\textbf{Parameters}
\begin{quote}

\emph{granule}    : granule name

\emph{roi}        : region of interest file

\emph{spatialrel} : spatial relationship (i.e. ST\_Contains or ST\_Intersect)

\emph{proj}       : projection name

\emph{inst}       : instance id (i.e. a 5-digit string)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{ullr}       : upper left, lower right tupple pair in the projection given
\end{quote}

\end{fulllineitems}

\index{qryFromFile() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qryFromFile}\pysiglinewithargsret{\bfcode{qryFromFile}}{\emph{fname}, \emph{path}, \emph{output=False}}{}
Runs a query in the current databse by opening a file - adds the path and 
.sql extension - reading contents to a string and running the query

\textbf{Note:} do not use \% in the query b/c it interfers with the pyformat protocol
used by psycopg2

\textbf{Parameters}
\begin{quote}

\emph{fname}  : file name (don't put the sql extension, it's assumed)

\emph{path}   : full path to fname

\emph{output} : make true if you expect/want the query to return results
\end{quote}

\end{fulllineitems}

\index{qryFromText() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qryFromText}\pysiglinewithargsret{\bfcode{qryFromText}}{\emph{sql}, \emph{output=False}}{}
Runs a query in the current databse by sending an sql string

\textbf{Note:} do not use \% in the query b/c it interfers with the pyformat protocol
used by psycopg2; also be sure to triple quote your string to avoid escaping single quotes;
IF EVER THE Transaction block fails, just conn.rollback();try to use pyformat for queries - see dbapi2 (PEP);
you can format the SQL nicely with an online tool - like SQLinForm

\textbf{Parameters}
\begin{quote}

\emph{sql}    : the sql text that you want to send

\emph{output} : make true if you expect/want the query to return results
\end{quote}

\textbf{Returns}
\begin{quote}

The result of the query as a tupple containing a numpy array and the column names as a list (if requested and available)
\end{quote}

\end{fulllineitems}

\index{qryGetInstances() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qryGetInstances}\pysiglinewithargsret{\bfcode{qryGetInstances}}{\emph{granule}, \emph{roi}, \emph{spatialrel}, \emph{proj}}{}
Writes a query to fetch the instance names that are
associated spatially in the relational table.

\textbf{Parameters}
\begin{quote}

\emph{granule}    : granule name

\emph{roi}        : region of interest file

\emph{spatialrel} : spatial relationhip (i.e. ST\_Contains or ST\_Intersect)

\emph{proj}       : projection name
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{instances}  : instances id (unique for entire project, i.e. 5-digit string)
\end{quote}

\end{fulllineitems}

\index{qryMaskZone() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qryMaskZone}\pysiglinewithargsret{\bfcode{qryMaskZone}}{\emph{granule}, \emph{roi}, \emph{spatialrel}, \emph{proj}, \emph{inst}}{}
Writes a query to fetch the gml polygon of the area that the inst polygon and
image in question intersect.
returns gml text but also saves a file... mask.gml in the current dir

\textbf{Parameters}
\begin{quote}

\emph{granule}    : granule name

\emph{roi}        : region of interest file

\emph{spatialrel} : spatial relationship (i.e. ST\_Contains or ST\_Intersect)

\emph{proj}       : projection name

\emph{inst}       : instance id (i.e. a 5-digit string)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{polytext}  :   gml text
\end{quote}

\end{fulllineitems}

\index{qrySelectFromArchive() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qrySelectFromArchive}\pysiglinewithargsret{\bfcode{qrySelectFromArchive}}{\emph{roi}, \emph{spatialrel}, \emph{proj}}{}
Given a table name (with polygons, from/todates), determine the scenes that cover the area
from start (str that looks like iso date) to end (same format).
\begin{description}
\item[{Eventually include criteria:}] \leavevmode
subtype - a single satellite name: ALOS\_AR, RADAR\_AR, RSAT2\_AR (or ANY)        
beam - a beam mode

\end{description}

comes back with - a list of images+inst - the bounding box

\textbf{Parameters}
\begin{quote}

\emph{roi}        : region of interest table in the database

\emph{spatialrel} : spatial relationship (i.e. ST\_Contains or ST\_Intersect)

\emph{proj}       : projection name
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{copylist} : a list of image catalog ids

\emph{instimg}  : a list of each instance and the images that correspond
\end{quote}

\end{fulllineitems}

\index{qrySelectFromLocal() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.qrySelectFromLocal}\pysiglinewithargsret{\bfcode{qrySelectFromLocal}}{\emph{roi}, \emph{spatialrel}, \emph{proj}}{}
Determines the scenes that cover the area (spatialrel = contains or intersects)
from start (str that looks like iso date) to end (same format).

Eventually include criteria:
\begin{quote}
\begin{quote}

subtype - a single satellite name: ALOS\_AR, RADAR\_AR, RSAT2\_AR (or ANY)
\end{quote}

beam - a beam mode
\end{quote}

comes back with - a list of images+inst - the bounding box

\textbf{Parameters}
\begin{quote}

\emph{roi}        : region of interest

\emph{spatialrel} : spatial relationship (i.e. ST\_Contains or ST\_Intersect)

\emph{proj}       : projection
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{copylist}   : a list of image names including full paths

\emph{instimg}    : a list of the images and their corresponding instance ids
\end{quote}

\end{fulllineitems}

\index{sql2numpy() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.sql2numpy}\pysiglinewithargsret{\bfcode{sql2numpy}}{\emph{sqlArray}, \emph{dtype='float32'}}{}
Comming from SQL queries, arrays are stored as a list (or list of lists)
Defaults to float32

\textbf{Parameters}
\begin{quote}

\emph{sqlArray} : an sql friendly array

\emph{dtype}    : default type (float32)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{list}     : list containing the arrays
\end{quote}

\end{fulllineitems}

\index{updateFromArchive() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.updateFromArchive}\pysiglinewithargsret{\bfcode{updateFromArchive}}{\emph{archDir}}{}
Goes to CIS Archive metadata shapefiles and (re)creates and updates tblArchive in the connected database
tblArchive then represents all the image files that CIS has (in theory)
The first thing this script does is define the table - this is done from an sql file and contains the required SRID
Then it uses ogr2ogr to upload each shp in the archDir 
The script looks for the {\color{red}\bfseries{}*}.last files to know which files are the most current (these need to be updated)

Can be extended to import from other archives (In the long term - PDC?)

\textbf{Parameters}
\begin{quote}

\emph{archDir} : archive directory
\end{quote}

\end{fulllineitems}

\index{updateROI() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.updateROI}\pysiglinewithargsret{\bfcode{updateROI}}{\emph{inFile}, \emph{path}, \emph{proj}, \emph{ogr=False}}{}
This function will update an ROI (Region Of Interest) table in the database. It has a prescribed format
It will take the shapefile named inFile and update the database with the info

Note that this will overwrite any table named \emph{inFile} in the database

The generated table will include a column \emph{inst} - a unique identifier created by 
concatenating obj and instid

\textbf{Parameters}
\begin{quote}

\emph{inFile}   : basename of a shapefile (becomes an roi table name too)

\emph{path}     : full path to inFile

\emph{proj}     : projection name
\end{quote}

\textbf{Required}
\begin{quote}

\emph{obj}      - the id or name of an object/polygon that defines a region of interest. Very systematic, no spaces.

\emph{instid}   - a number to distinguish repetitions of each obj in time or space.  For example an ROI that occurs several summers would have several instids.

\emph{fromdate} - a valid iso time denoting the start of the ROI - can be blank if imgref is used

\emph{todate}   - a valid iso time denoting the start of the ROI - can be blank if imgref is used
\end{quote}

\textbf{Optional}
\begin{quote}

\emph{imgref}   - a reference image dimage name (for a given ROI) - this can be provided in place of datefrom and dateto

\emph{name}     - a name for each obj (Area51\_1950s, Target7, Ayles)

\emph{comment}  - a comment field

Any other field can be added...
\end{quote}

\end{fulllineitems}

\index{update\_NTAI\_FLUX\_ROI() (Database.Database method)}

\begin{fulllineitems}
\phantomsection\label{code:Database.Database.update_NTAI_FLUX_ROI}\pysiglinewithargsret{\bfcode{update\_NTAI\_FLUX\_ROI}}{\emph{inFile}, \emph{path}, \emph{proj}}{}
Goes to a shapefile named inFile and updates the postGIS database
Assumes dbase postgis exists and that outTable does as well - this overwrites!

\textbf{Parameters}
\begin{quote}

\emph{inFile} : basename of a shapefile

\emph{path}   : full path to inFile

\emph{proj}   : projection name
\end{quote}

\textbf{Required}
\begin{quote}

name, inst, obj, type, fromdate, todate(optional)

fromdate - a valid time\_start (ie it is here, when was it here?)

todate   - a valid time\_end (ie it is here, when was it here?)

inst     - an instance id (unique for entire project) - Nominally a 5-digit string
\end{quote}

\textbf{Optional}
\begin{quote}

refimg   - a reference image name (ie how do you know it was here)

type     - an ice type (ie ice island, ice shelf, mlsi, fyi, myi, epishelf, open water)

subtype  - an ice subtype (ie ice island could be iced firn, basement; open water could be calm, windy)

comment  - a comment field

name     - a name (Target7, Ayles)

obj      - an object id tag (to go with name but very systematic: 2342, and if it splits 2342\_11 \& 2342\_12)
\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{Utilities}
\label{code:module-Util}\label{code:utilities}\index{Util (module)}
\textbf{util.py}

This module contains miscellaneous code that helps siglib work with directories, 
zip files, clean up intermediate files and so on.

\textbf{Created on} Tue Feb 12 20:04:11 2013 \textbf{@author:} Cindy Lopes
\textbf{Modified on} Sat Nov 23 14:49:18 2013 \textbf{@reason:} Added writeIssueFile and compareIssueFiles \textbf{@author:} Sougal Bouh Ali
\textbf{Modified on} Sat Nov 30 15:37:22 2013 \textbf{@reason:} Redesigned getFilname, getZipRoot and unZip \textbf{@author:} Sougal Bouh Ali
\textbf{Modified on} Wed May 23 14:41:40 2018 \textbf{@reason:} Added logging functionality \textbf{@author:} Cameron Fitzpatrick
\index{az() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.az}\pysiglinewithargsret{\code{Util.}\bfcode{az}}{\emph{pt1}, \emph{pt2}}{}
Calculates the great circle initial azimuth between two points
in dd.ddd format. 
This formula assumes a spherical earth.  Use Vincenty's formulae
for better precision

\href{https://en.wikipedia.org/wiki/Azimuth}{https://en.wikipedia.org/wiki/Azimuth}
\href{https://en.wikipedia.org/wiki/Vincenty\%27s\_formulae}{https://en.wikipedia.org/wiki/Vincenty\%27s\_formulae}

\textbf{Parameters:}
\begin{quote}

\emph{pt1} : point from (tuple of lon and lat)

\emph{pt2} : point to (tuple of lon and lat)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{az}  : azimuth from North in degrees
\end{quote}

\end{fulllineitems}

\index{cleartree() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.cleartree}\pysiglinewithargsret{\code{Util.}\bfcode{cleartree}}{\emph{dirname}}{}
Delet all files in a certain path

\textbf{Parameters}
\begin{quote}

\emph{dirname} :
\end{quote}

\end{fulllineitems}

\index{compareIssueFiles() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.compareIssueFiles}\pysiglinewithargsret{\code{Util.}\bfcode{compareIssueFiles}}{\emph{file1}, \emph{file2}, \emph{loghandler=None}}{}
Compares 2 clean issue files generated by writeIssueFile() and
generates a separate file containing the list of matched \& unmatched files in 2 files.

\textbf{Parameters}
\begin{quote}

\emph{file1} : name of the first text file with extension to be compared (i.e. textfile.txt)

\emph{file2} : name of the second text file with extension to be compared (i.e. textfile.txt)
\end{quote}

\end{fulllineitems}

\index{deltree() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.deltree}\pysiglinewithargsret{\code{Util.}\bfcode{deltree}}{\emph{dirname}}{}
Delete all the files and sub-directories in a certain path

\textbf{Parameters}
\begin{quote}

\emph{dirname}   :
\end{quote}

\end{fulllineitems}

\index{getFilename() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.getFilename}\pysiglinewithargsret{\code{Util.}\bfcode{getFilename}}{\emph{zipname}, \emph{unzipdir}, \emph{loghandler=None}}{}
Given the name of a zipfile, return the name of the image,
the file name, and the corresponding sensor/platform (satellite).

\textbf{Parameters}
\begin{quote}

\emph{zipname}  : The basename of the zip file you are working with

\emph{unzipdir} : Where the zipfile will unzip to (find out with getZipRoot)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{fname}    :  The file name that corresponds to the image

\emph{imgname}  : The name of the image (the basename, sans extension)

\emph{sattype}  : The type of satellite/image format this file represents
\end{quote}

\end{fulllineitems}

\index{getPowerScale() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.getPowerScale}\pysiglinewithargsret{\code{Util.}\bfcode{getPowerScale}}{\emph{dB}}{}
Convert a SAR backscatter value from the log dB scale to the linear power scale

\textbf{Note:} dB must be a scalar or an array of scalars

\textbf{Parameters}
\begin{quote}

\emph{dB}    : backscatter in dB units
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{power} : backscatter in power units
\end{quote}

\end{fulllineitems}

\index{getZipRoot() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.getZipRoot}\pysiglinewithargsret{\code{Util.}\bfcode{getZipRoot}}{\emph{zip\_file}, \emph{tmpDir}}{}
Looks into a zipfile and determines if the contents will unzip into a subdirectory
(named for the zipfile); or a sub-subdirectory; or no directory at all (loose files)

Run this function to determine where the files will be unzipped to. If the files are in
the immediate subfolder, then that is what is required.

Returns the unzipdir (where the files will -or should- go) and zipname (basename of the zipfile)

\textbf{Parameters}
\begin{quote}

\emph{zip\_file} : full path, name and ext of a zip file

\emph{tmpDir}   : this is the path to the directory where you are working with this file (the path of the zip\_file - or wrkdir)
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{unzipdir} : the directory where the zip file will/should unzip to

\emph{zipname}  : basename of the zip file AND/OR the name of the folder where the image files are
\end{quote}

\end{fulllineitems}

\index{getdBScale() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.getdBScale}\pysiglinewithargsret{\code{Util.}\bfcode{getdBScale}}{\emph{power}}{}
Convert a SAR backscatter value from the linear power scale to the log dB scale

\textbf{Note:} power must be a scalar or an array of scalars,negative powers will throw back NaN.

\textbf{Parameters}
\begin{quote}

\emph{power} : backscatter in power units
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{dB}    : backscatter in dB units
\end{quote}

\end{fulllineitems}

\index{llur2ullr() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.llur2ullr}\pysiglinewithargsret{\code{Util.}\bfcode{llur2ullr}}{\emph{llur}}{}
a function that returns:
upperleft, lower right when given...
lowerleft, upper right
a list of tupples {[}(x,y),(x,y){]}

Note - this will disappoint if proj is transformed (before or after)

\textbf{Parameters}
\begin{quote}

\emph{llur} : a list of tupples {[}(x,y),(x,y){]} corresponding to lower left, upper right corners of a bounding box
\end{quote}

\end{fulllineitems}

\index{reprojSHP() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.reprojSHP}\pysiglinewithargsret{\code{Util.}\bfcode{reprojSHP}}{\emph{in\_shp}, \emph{vectdir}, \emph{proj}, \emph{projdir}}{}
Opens a shapefile, saves it as a new shapefile in the same directory
that is reprojected to the projection wkt provided.

\textbf{Note:} this could be expanded to get polyline data from polygon data
for masking lines (not areas) ogr2ogr -nlt MULTILINESTRING

\textbf{Parameters}
\begin{quote}

\emph{in\_shp}  :

\emph{vectdir} :

\emph{proj}    :

\emph{projdir} :
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{out\_shp} : name of the proper shapefile
\end{quote}

\end{fulllineitems}

\index{ullr2llur() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.ullr2llur}\pysiglinewithargsret{\code{Util.}\bfcode{ullr2llur}}{\emph{ullr}}{}
a function that returns:
lowerleft, upper right when given...
upperleft, lower right
a list of tupples {[}(x,y),(x,y){]}

Note - this will disappoint if proj is transformed (before or after)

\textbf{Parameters}
\begin{quote}

\emph{ullr} : a list of tupples {[}(x,y),(x,y){]} corresponding to upper right, lower left corners of a bounding box
\end{quote}

\end{fulllineitems}

\index{unZip() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.unZip}\pysiglinewithargsret{\code{Util.}\bfcode{unZip}}{\emph{zip\_file}, \emph{unzipdir}, \emph{ext='all'}}{}
Unzips the zip\_file to unzipdir with python's zipfile module.

``ext'' is a keyword that defaults to all files, but can be set
to just extract a leader file L or xml for example.

\textbf{Parameters}
\begin{quote}

\emph{zip\_file} : Name of a zip file - with extension
\begin{quote}

\emph{unzipdir} : Directory to unzip to
\end{quote}
\end{quote}

\textbf{Optional}
\begin{quote}

\emph{ext}      : `all' or a specific ext as required
\end{quote}

\end{fulllineitems}

\index{wkt2shp() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.wkt2shp}\pysiglinewithargsret{\code{Util.}\bfcode{wkt2shp}}{\emph{shpname}, \emph{vectdir}, \emph{proj}, \emph{projdir}, \emph{wkt}}{}
Takes a polygon defined by well-known-text and a projection name and outputs
a shapefile into the current directory

\textbf{Parameters}
\begin{quote}

\emph{shpname} :

\emph{vectdir} :

\emph{proj}    :

\emph{projdir} :

\emph{wkt}     :
\end{quote}

\end{fulllineitems}

\index{wktpoly2pts() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.wktpoly2pts}\pysiglinewithargsret{\code{Util.}\bfcode{wktpoly2pts}}{\emph{wkt}, \emph{bbox=False}}{}
Converts a Well-known Text string for a polygon into a series of tuples that
correspond to the upper left, upper right, lower right and lower left corners

This works with lon/lat rectangles.

If you have a polygon that is not a rectangle, set bbox to True and the 
bounding box corners will be returned

Note that for rectangles in unprojected coordinates (lon/lat deg), this is 
slightly different from ullr or llur (elsewhere in this project) which are 
derived from bounding boxes of projected coordinates

\textbf{Parameters}
\begin{quote}

\emph{wkt}         : a well-known text string for a polygon
\end{quote}

\textbf{Returns}
\begin{quote}

\emph{ul,ur,lr,ll} : a list of the four corners
\end{quote}

\end{fulllineitems}

\index{writeIssueFile() (in module Util)}

\begin{fulllineitems}
\phantomsection\label{code:Util.writeIssueFile}\pysiglinewithargsret{\code{Util.}\bfcode{writeIssueFile}}{\emph{fname}, \emph{delimiter}, \emph{loghandler=None}}{}
Generates a clean list of zipfiles, when given an Issue File written by scripts.

\textbf{Parameters}
\begin{quote}

\emph{fname}     :   name of the text file with extension to be cleaned(i.e. textfile.txt)

\emph{delimiter} :   separator used to split zipfile from unwanted errors (i.e. use most common '' / '' before zipfile)
\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\texttt{Database}}, \pageref{code:module-Database}
\indexspace
\bigletter{i}
\item {\texttt{Image}}, \pageref{code:module-Image}
\indexspace
\bigletter{m}
\item {\texttt{Metadata}}, \pageref{code:module-Metadata}
\indexspace
\bigletter{s}
\item {\texttt{SigLib}}, \pageref{code:module-SigLib}
\indexspace
\bigletter{u}
\item {\texttt{Util}}, \pageref{code:module-Util}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
